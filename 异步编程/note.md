# 异步编程
## 1. 前置知识
    1). JS语言的执行环境是"单线程", 也就是我们写的所有js代码都是在一个线程(主线程)上执行
    2). 理解单线程: 
        就是指一次只能完成一件任务。
        如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推
    3). js执行任务的2种模式
        同步（Synchronous）: 
            后一个任务等待前一个任务结束，然后再执行，
            程序的执行顺序与任务的排列顺序是一致的、同步的
        异步（Asynchronous）
            每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，
            后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。
    4). 为什么需要异步JS?
        浏览器端: 
            耗时很长的操作都应该异步执行，避免浏览器失去响应
            给时机让浏览器能去更新界面, 响应用户操作
        Node端:
            "异步模式"是唯一的模式，执行环境是单线程的
            处理请求的回调函数/数据库操作/文件读写操作都必须是异步处理, 否则处理多个请求时很快就会失去响应
    5). JS常用的异步编码方式
        a. 回调函数
        b. 事件机制
        c. 消息订阅与发布 / 全局事件总线
        d. Promise

## 2. 回调函数
    异步编程最基本的方法, 所有模式都是在此基础上进行封装扩展而来
    回调函数的执行模式:
        异步执行
        同步执行
    异步回调的缺点: 
        不利于代码的阅读和维护，各个部分之间高度耦合。
        容易导致回调地狱问题

## 3. 事件监听
    事件驱动模式: 
        任务的执行不取决于代码定义的顺序，而取决于某个事件是否发生
        事件监听函数定义时不会执行, 只有当事件发生(分发事件)后才执行
    分类:
        原生DOM事件
        自定义事件
    操作:
        在某个元素/组件对象上绑定特定事件监听
        在某个元素/组件对象上分发事件
    特点:
        针对某个DOM元素绑定监听和分发事件
        针对某个组件对象绑定监听和分发事件

## 4. 消息订阅/发布与全局事件总线
    消息订阅/发布:
        订阅全局消息
        发布全局消息
    全局事件总线:
        绑定事件监听
        分发事件
    特点:
        分发事件后, 所有同名的事件监听回调都会调用

## 5. Promise
    实现异步编程新的通用解决方案
    相对于纯回调的优势
        指定异步回调函数的方式更灵活(可以在启动异步任务后,甚至可以在异步任务完成后)
        通过then的链式调用解决回调地狱的问题
    不足: 还需要指定回调函数

## 6. async/await
    基于promise的语法糖, 简化了promise对象的使用(不再使用回调函数编码)
    以同步编码方式实现的异步流程
    是js异步编程的终极解决方案(基本上可以这样说)

## 7. JS事件循环机制
    js是单(主)线程运行的
    js的回调函数可以异步执行
    js通过event-loop机制实现了js的单线程异步执行
        JS引擎解析执行js代码总是在主线程执行(WebWorks除外)
        浏览器有在分线程执行的对应管理模块(浏览器是多线程执行的)
            定时器
            DOM事件监听
            ajax请求
            Promise
        JS引擎有专门的回调队列, 缓存待执行的回调函数
            宏队列
            微队列
