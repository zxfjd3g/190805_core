## 1. 二种特别的数据结构
    1). 栈(stack)
        理解: 有序保存多个数据, 后进先出(LIFO), 先保存(入栈)的在栈底, 后保存的在栈顶, 能取出(出栈)的只能是栈顶的数据 
        应用: 函数调用栈
    3). 队列(queue)
        理解: 有序保存多个数据, 先进先出(FIFO), 先保存的在队头, 后保存的在队尾, 能取出的只能是队头的数据
        应用: 回调队列

## 2. stack内存与heap内存
    1). stack内存: 
        也就是堆栈内存/空间, 也称栈内存/空间
        存储函数运行产生的局部变量, 大小固定, 函数执行完自动全部释放
    2). heap内存: 
        也就是堆内存/空间
        存储对象, 由垃圾回收器回收释放对象(没有引用指向的) 
    3). js中只有堆(heap)内存, 没有栈(stack)内存
        所有的数据都保存在heap空间, 无论是创建的对象还是定义的变量(全局/局部)
    4). 有的语言, 如: Java语言中有heap空间和stack空间
        
## 3. js的内存管理
    0). MDN文档: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management
    1). 内存生命周期
        分配你所需要的内存: 自动分配
        使用分配到的内存（读、写）
        不需要时将其释放\归还: 利用垃圾回收器自动回收
    2). JS的垃圾回收机制: 标记-清除算法
        所有现代浏览器都使用了标记-清除垃圾回收算法或基于它的优化算法
        算法:  假定设置一个叫做根（root）的对象（在浏览器端就是全局对象Window）。
              垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象
              标记它们正在使用中, 而未被标记的对象就是垃圾对象, 垃圾回收器就会回收释放它们的空间
    3). 内存泄漏与内存溢出
        内存泄漏: 不再使用的内存空间没有及时释放
            未清除的定时器/监听
            意外的全局变量
            未及时释放的闭包变量
        内存溢出: 程序运行需要的内存空间超过的能分配的最大内存空间

## 4. 执行上下文(EC)与执行上下文栈(ECS)
    1). 执行上下文(Excute Context)
        全局环境 ==> 全局执行上下文 ==> 只有一个
        函数环境 ==> 函数执行上下文 ==> 每执行函数都会创建一个新的
    2). 执行上下文栈(Excute Context Stack)
        JS引擎以栈的结构管理程序执行过程产生的多个执行上下文
        call stack(执行栈), 栈底永远是全局执行上下文, 栈顶是当前正在执行的上下文
    3). 函数执行上下文生命周期
        创建阶段: 生成变量对象 / 确认作用域链 / 确定this指向
        执行阶段: 变量赋值 / 执行其它代码
        回收释放: 执行结束后出栈, 等待垃圾回收器回收释放

## 5. 变量对象(VO|Variable Object)
    1). 理解
        JS引擎内部用来存储变量的对象
    2). 分类
        全局变量对象: 就是window, 它在程序中直接可见, 且其属性可以直接访问
            全局函数声明
            全局变量声明
        函数变量对象: 调用函数时动态创建, 它在程序中不可见, 只能看到其内部属性
            函数的参数/arguments
            函数声明
            变量声明
    3). JS引擎执行代码流程
        执行全局代码
            a. 执行全局代码前(创建阶段) 
                ==> 确定window对象为全局变量对象, 
                ==> 将函数声明添加为window的方法
                ==> 将变量声明添加为window的属性
            b. 执行全局代码(执行阶段)
                ==> 读取window中的属性值
                ==> 给window中的属性赋值
                ==> 执行window的方法
        执行函数
            a. 执行函数体前(创建阶段) 
                ==> 创建一个新的变量对象
                ==> 将形参变量及其值保存为变量对象的属性
                ==> 将arguments保存为变量对象的属性
                ==> 将函数声明保存为变量对象的方法  ==> 函数声明提升
                ==> 将变量声明保存为变量对象的属性, 属性值为undefined  ==> 变量声明提升
            b. 执行函数体(执行阶段)
                ==> 读取变量的值 --> 根据作用域链查找变量对象上的对应属性值取出
                ==> 给变量赋值 --> 根据作用域链查找变量对象上的对应属性, 给其赋值
                ==> 调用函数 --> 根据作用域链查找变量对象上的对应方法执行
    4). 活动对象(AO|Activation Object)   
        执行函数时产生的变量对象也称为活动对象
    5). 提升的先后和重名问题
        先函数提升, 再变量提升
        2个同名函数声明, 后面的会覆盖前面的
        2个同名变量声明, 后面的会被忽略
        同名的函数声明与变量声明, 变量声明会被忽略

## 6. 作用域与作用域链
    1). 作用域
        作用域是指程序源代码中定义的变量的可访问区域。
        作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。
        JS采用词法作用域(lexical scoping)，也就是静态作用域。
        
    2). 静态作用域与动态作用域
        静态作用域: 函数的作用域在函数定义的时候就决定了
        动态作用域: 函数的作用域是在函数调用的时候才决定的

    3). 作用域链
        由多个执行上下文的变量对象组成的链
        函数有一个内部属性 [[scopes]]，当函数创建的时候，就会保存所有父变量对象到其中，
        可以认为 [[scopes]] 就是所有父级变量对象的层级链，注意：[[scopes]] 并不代表完整的作用域链
        
## 7. 闭包
    1). 是什么?
        MDN: 闭包是函数和声明该函数的词法环境的组合
        理解: 闭包 = 函数 + 函数内访问的外部的局部变量
    2). 产生闭包的条件
        函数嵌套
        内部函数访问了外部函数的局部变量
        外部函数调用 ===> 内部函数对象产生
    3). 闭包产生的本质
        作用域链